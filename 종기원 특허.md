
1. 발명의 명칭

결함 위치 추정에서 프로그램 코드의 패턴을 고려한 결함 의심도 점수 변환 기술


2. 발명의 이용분야  

- 본 발명이 응용될 수 있는 분야를 재료/부품/최종제품 등의 다양한 관점에서 기재

본 발명은 결함 의심도 점수를 후처리하는 기술 (post-processing  technique) 형태로 소프트웨어 결함의 위치를 추정하는 스펙트럼 기반 결함 위치 추정기(spectrum-based fault localization technique)에 탑재될 수 있음.


3. 종래 기술 및 문제점

3-1. 종래 기술의 설명 

종래에는 소프트웨어에서 오류가 발생 시 오류의 원인이 되는 결함의 위치를 자동으로 추정하기 위해 테스트케이스의 실행정보만을 기반으로 결함의 위치를 추정하는 스펙트럼 기반 결함 위치 추정 기술이 사용되었음. 

가장 대표적인 스펙트럼 기반 결함 위치 추정 기술인 Ochiai [1]의 경우 테스트케이스 실행 정보를 기반으로 아래의 식을 적용하여 각 프로그램 라인 별 결함 의심도 점수를 계산함.

![[Pasted image 20240125105503.png]]

위 식에서 $N_{CF}$ 는 프로그램 라인을 지나가는 실패 테스트 케이스의 개수, $N_{CS}$는 프로그램 라인을 지나가는 성공 테스트 케이스의 개수, $N_{F}$는 실패 테스트케이스의 총 개수를 의미함. 위 식을 적용해 각 라인별 의심도 점수를 계산 후 높은 의심도 점수를 가지는 라인을 오류를 일으키는 결함 라인으로서 추정함. Ochiai 이외에도 다양한 스펙트럼 기반 결함 위치 추정 기술들이 존재하고[2] 이들은 대부분 테스트케이스 실행 정보만을 기반으로 이를 식으로 조합해 각 라인별 의심도 점수를 계산 후 결함의 위치를 추정함.


3-2. 종래 기술의 문제점  

종래의 기술은 테스트케이스의 실행 정보만을 이용하여 결함의 위치를 추정하기 때문에, 의심스러운 코드 패턴과 같은 정보를 고려하지 못함. 예를 들어 아래는 C++코드 정적분석기인 cppcheck[3]의 개발 과정 중 발생한 결함 및 이에 대한 수정임.
![[Pasted image 20240125110900.png]]
위와 비슷한 결함(복잡한  if문)은 cppcheck[3]의 개발 과정 중 지속해서 발생함. 예를 들어 얼마 후 아래와 같은 결함 및 수정이 발생하였음.
![[Pasted image 20240125131018.png]]
즉, cppcheck 프로젝트에서는 위처럼 복잡한 if 구문이 자주 발생하는 결함 패턴임. 위와 같은 결함 코드 패턴을 파악하여 이를 이용하면 결함의 위치 추정의 정확도를 향상시켜줄 수 있지만, 실행정보만을 기반으로 결함의 위치를 추정하는 종래의 스펙트럼 결함 위치 추정 기술은 위와 같은 결함 코드 패턴을 활용하지 못함.



4. 발명의 원리/구성

본 발명(결함 코드 패턴을 고려한 의심도 점수 업데이트 기술)은 의심도 점수  후처리 기술 (post-processing  technique)로써 스펙트럼 기반 결함 위치 추정 기술에 의해 각 라인 별 초기 의심도 점수 계산 후 결함 코드 패턴을 고려하여 의심도 점수를 업데이트하는 기술임. 본 발명의 기술이 탑재된 결함 위치 추정 방법의 동작 방식은 아래와 같음.

![[Pasted image 20240125112331.png]]

최신버전의 프로젝트(Latest version of the project including faults)에서 결함이 발생 시 종래의 스펙트럼 기반 결함 위치 추정기(Baseline FL)를 사용하여 각 라인 별 초기 의심도 점수를 개발함. 이후 결함 패턴을 고려함 의심도 점수 업데이트 함수 (Crossword)를 적용하여 각 라인 별 의심도 점수를 업데이트하고. 새로운 의심도 점수를 기반으로 결함의 위치를 추정함. 의심도 점수 업데이트 함수는 프로젝트의 이전 버전의 결함 데이터들로부터 학습한 해당 프로젝트에서 자주 발생하는 결함 패턴 및 이에 대한 의심도 점수 업데이트 방법임.

![[Pasted image 20240125130920.png]]

위 그림은 의심도 점수 업데이트 함수의 한 예시임. 의심도 점수 업데이트 함수는 5개의 노드로 구성되어 있는 그래프이고 결함 패턴 및 이에 대한 의심도 점수 상승 폭을 표현하고 있음. 위 의심도 점수 업데이트 함수는 프로그램 라인에 'if'문이 있을 경우 의심도 점수를 0.13점 상승시킴. 또한, 대상 프로그램 라인의 브랜치(branch)에 해당하는 라인에 'return'문이 있을 경우 의심도 점수를 0.13점 상승시킴. 예를 들어 위  cppcheck프로젝트의 결함 라인들은 모두 'if'문이 있고 브랜치(branch)에 해당하는 라인에 'return'문이  존재하므로 의심도 점수는 0.26점 상승함. 

  

5. 대표 실시예  

본 발명(결함 코드 패턴을 고려한 의심도 점수 업데이트 기술)을 설명하기 위해 아래의 예제를 사용하겠음.

5-1. 대표 실시예  
![[Pasted image 20240125133026.png]]

위 예시의 (a)는 예제 프로그램 코드임. 예제 프로그램은 6개의 프로그램 라인으로 구성되어 있음(s1,s2,s3,s4,s5,s6). 예시의 (b)는 프로그램이 만족해야 하는 5개의 테스트 케이스 입출력임. 예를 들어 5개의 입력 1, 99, 100, 101, 200에 대해서 각각 1, 99, 100, -101, -200을 출력해야 한다는 것임. 하지만, 그림 8 (a)의 프로그램은 세 번째 테스트 케이스 100에 대해서 -100을 출력하기 때문에 (a)의 프로그램은 결함이 있음. s4에 해당하는 라인이 결함 라인이고 “>=”은 “>”로 수정되어야 함.

예시의 (c) 는 예시 (a)의 프로그램의 각 라인을 들여쓰기를 기준으로 분류하여 나무 형태로  표현한 것임. 들여쓰기 나무에서 각 노드는 하나의 프로그램 라인을 표현하고 있고, 파란색 엣지는 프로그램에서 들여쓰기의 깊이가 다름(branch 관계)을 표현하고 있음. 반면, 빨간색 엣지는 들여쓰기의 깊이가 같음(sequential 관계)을 표현하고 있음. 예를 들어 s4는 s5와 파란색 엣지로 연결되고 (branch 관계), s3은 s4와 빨간색 엣지 (sequential한 관계)로 연결됨. 들여쓰기 나무는 프로그램의 각 라인별 들여쓰기 분석(구문 분석)만으로 쉽게 얻어낼 수 있음. 예시 (d)의 의심도 점수 변환 함수는 오류가 발생한 프로그램의 들여쓰기 나무를 활용해 각 라인별 의심도 점수를 업데이트함. 


5-2. 관련 도면  

의심도 점수 변환 함수(Crossword)의 문법과 의미는 다음과 같이 정의됨.

**문법(Syntax).** 의심도 점수 변환 함수(Crossword)는 아래와 같이 5개의 노드들로 정의됨.

$Crossword = Node \times Node \times Node \times Node \times Node$

위 예시 (d)의 경우 5개의 노드들 $(n_1,n_2,n_3,n_4,n_5)$로 구성되어 있고, 첫번째 노드 $n_1$은 (d)의 중앙(어두운)노드에 대응됨. 두 번째와 세 번째 노드들($n_2,n_3$)은 각각 (d)의 중앙노드와 붉은색 엣지로 된 선행(predecessor)과 후속(successor)노드들임 .네 번째와 다섯 번째 노드들 ($n_4,n_5$)은 중앙 노드와 푸른색 엣지로 연결된 선행(predecessor)과 후속(successor) 노드들임.

의심도 점수 변환 함수의(crossword)의 노드들은 각 토큰 별 등장했을 시 중앙 (어두운) 노드에 해당하는 프로그램 라인의 의심도 점수를 변화시킬 실수를 표현함.

$Node = Token \to \mathbb{R}$

**의미(Semantics).** 위에서 설명한 바와 같이 의심도 점수 변환 함수(Crossword)는 기존의 의심도 점수, 해당 라인, 프로그램을 입력으로 받아 새로운 의심도 점수를 계산하는 함수임. 주어진 프로그램 $p$에서 베이스라인 결함 위치 추정기술에 의해 계산된 라인 $s$의 초기 의심도 점수를  $r\in \mathbb{R}$이라 였을 때, 의심도 점수 변환 함수 $(n_1,n_2,n_3,n_4,n_5)$는 해당 라인의 새로운 의심도 점수를 다음과 같이 계산함.

$r + \sum_{t \in tokens(s)}n_1(t) + \sum_{t \in tokens(pred(s,p))}n_2(t)+ \sum_{t \in tokens(succ(s,p))}n_3(t)$ 
$+ \sum_{t \in tokens(parent(s,p))}n_4(t)+ \sum_{t \in tokens(child(s,p))}n_5(t)$

위 식에서 $tokens(s)$는 라인 $s$에 속한 모든 토큰들의 집합을 의미함. $pred(s,p)$는 프로그램 $p$의 들여쓰기 나무에서 라인 $s$에 해당하는 노드와 붉은색 엣지로 연결된 선행 노드에 해당하는 라인, $succ(s,p)$는 프로그램 $p$의 들여쓰기 나무에서 라인 $s$에 해당하는 노드와 붉은색 엣지로 연결된 후속 노드에 해당하는 라인, $parent(s,p)$는 프로그램 $p$의 들여쓰기 나무에서 라인 $s$에 해당하는 노드와 푸른색 엣지로 연결된 선행 노드에 해당하는 라인, $child(s,p)$는 프로그램 $p$의 들여쓰기 나무에서 라인 $s$에 해당하는 노드와 푸른색 엣지로 연결된 후속 노드에 해당하는 라인을 의미함.



5-3. 대표 실시예 설명 및 효과  

예시 (d)의 의심도 점수 변환 함수 프로그램의 들여쓰기나무 (c)를 참고해 각 라인의 의심도 점수를 업데이트함. 예를 들어 (c)에서 s1에 해당하는 라인은 s6에 해당하는 라인("    return y;" )이 ‘y’를 포함함으로 의심도 점수가 0.13점 상승함. s2의 경우 s3(" y=x;")이 ‘y’를 포함하고 s1("int fun(int x){")이 ‘x’를 포함하여 의심도 점수가 0.26(0.13 + 0.13)점 승함. s3과 s6의 경우 s1의 ‘x’로 인해 의심도 점수가 0.13점 상승함. s4(실제 결함 라인)의 경우 의심도 점수가 가장 많이 향상되는데 해당 라인(
"  if (x >=100){")의 ‘if’, s1의 ‘x’, s5의 ‘return’과 ‘y’, s6의 ‘y’로 인해 의심도 점수는 0.65(0.13 + 0.13 + 0.13 + 0.13 + 0.13)점 상승함. 반면, s5의 경우 만족하는 조건이 없기 때문에 의심도 점수는 업데이트되지 않음. 만약 Ochiai[1]를 베이스라인 결함 위치 추정 기술로 사용했다고 위와 같은 점수 변환이 반영되었다면 점수는 아래와 변환됨.

![[Pasted image 20240125135335.png]]

의심도 점수 업데이트 전(Ochiai만을 적용)에는 결함 라인이 아닌 s5가 0.57로 가장 높은 의심도 점수를 받았음. 하지만 의심도 점수 업데이트 후에는 실제 결함 라인인 s4가 1.22로 가장 높은 의심도 점수를 받게 되어 실제 결함 라인을 정확하게 가장 의심스러운 라인으로 추정함.




6. 추가 실시 예

위 대표 실시 예에서는 5개의 노드만으로 구성된 점수 변환 함수를 정의하고 사용하였지만, 점수 변환 함수(crossword)가 임의의 개수의 노드를 가질 수 있도록 확장할 수 있음. 

6-1. 추가 실시 예 1  
아래 예시는 6개의 노드로 구성된 점수 변환 업데이트 함수임.

![[Pasted image 20240125143844.png]]

6-2. 관련 도면  

위 점수 변환 함수의 의미는 5-2에서 정의한 문법 및 의미를 확장하여 쉽게 정의할 수 있음. 

**문법(Syntax).** 확장된 의심도 점수 변환 함수(Crossword')는 아래와 같이 6개의 노드들로 정의됨.

$Crossword' = Node \times Node \times Node \times Node \times Node \times Node$

**의미(Semantics).** 주어진 프로그램 $p$에서 베이스라인 결함 위치 추정 기술에 의해 계산된 라인 $s$의 초기 의심도 점수를  $r\in \mathbb{R}$이라 였을 때, 의심도 점수 변환 함수 $(n_1,n_2,n_3,n_4,n_5,n_6)$는 해당 라인의 새로운 의심도 점수를 다음과 같이 계산함.

$r + \sum_{t \in tokens(s)}n_1(t) + \sum_{t \in tokens(pred(s,p))}n_2(t)+ \sum_{t \in tokens(succ(s,p))}n_3(t)$ 
$+ \sum_{t \in tokens(parent(s,p))}n_4(t)+ \sum_{t \in tokens(child(s,p))}n_5(t)+\sum_{t \in tokens(succsucc(s,p))}n_6(t)$
위 식에서 $succsucc(s,p)$는 프로그램 $p$의 들여쓰기 나무에서 라인 $s$에 해당하는 노드와 붉은색 엣지로 연결된 후속 노드의 후속 노드에 해당하는 라인임.


6-3. 추가 실시예 설명 및 효과  

위 6-2에서 정의한 6개의 노드들로 구성된 의심도 점수 변환 함수는 5-2에서 정의한 5개의 노드들로 구성된 의심도 점수 변환 함수와 비교해 더 높은 표현력을 가지고 있음. 예를 들어 5개의 노드들로 구성된 의심도 점수 변환 함수는 6개의 노드들로 구성된 의심도 점수 변환 함수의 마지막 노드는 항상 임의의 토큰에 대해서 0점을 부여하는것과 같음. 


6-4. 추가 실시예 3  

아래 예시는 7개의 노드로 구성된 점수 변환 업데이트 함수임.

![[Pasted image 20240125144628.png]]

6-5. 관련 도면  

위 점수 변환 함수의 의미는 5-2 및 6-2에서 정의한 문법 및 의미를 확장하여 쉽게 정의할 수 있음. 

**문법(Syntax).** 확장된 의심도 점수 변환 함수(Crossword')는 아래와 같이 6개의 노드들로 정의됨.

$Crossword' = Node \times Node \times Node \times Node \times Node \times Node \times Node$

**의미(Semantics).** 주어진 프로그램 $p$에서 베이스라인 결함 위치 추정 기술에 의해 계산된 라인 $s$의 초기 의심도 점수를  $r\in \mathbb{R}$이라 였을 때, 의심도 점수 변환 함수 $(n_1,n_2,n_3,n_4,n_5,n_6)$는 해당 라인의 새로운 의심도 점수를 다음과 같이 계산함.

$r + \sum_{t \in tokens(s)}n_1(t) + \sum_{t \in tokens(pred(s,p))}n_2(t)+ \sum_{t \in tokens(succ(s,p))}n_3(t)$ 
$+ \sum_{t \in tokens(parent(s,p))}n_4(t)+ \sum_{t \in tokens(child(s,p))}n_5(t)+\sum_{t \in tokens(succsucc(s,p))}n_6(t)$
$+\sum_{t \in tokens(predpred(s,p))}n_7(t)$
위 식에서 $predpred(s,p)$는 프로그램 $p$의 들여쓰기 나무에서 라인 $s$에 해당하는 노드와 붉은색 엣지로 연결된 선행 노드의 선행 노드에 해당하는 라인임.


6-6. 추가 실시예 설명 및 효과

위 6-5에서 정의한 6개의 노드들로 구성된 의심도 점수 변환 함수는 5-2 및 6-2에서 정의한 5-6개의 노드들로 구성된 의심도 점수 변환 함수와 비교해 더 높은 표현력을 가지고 있음. 예를 들어 6개의 노드들로 구성된 의심도 점수 변환 함수는 7개의 노드들로 구성된 의심도 점수 변환 함수의 마지막 노드는 항상 임의의 토큰에 대해서 0점을 부여하는것과 같음. 



7. 비교예

7-1. 비교예 1

**대조군:** 종래의 테스트케이스 실행 정보만을 사용하려 결함 위치를 추정하는 스펙트럼 기반 결함 위치 추정(spectrum-based fault localization)기술 중 가장 널리 사용되는 Ochiai [1].

**성능 측정용 벤치마크 프로그램:** 성능 비교를 위한 벤치마크는 bugscpp[2]를 사용함. bugscpp는 23 C++ 프로젝트에서 발생한 결함을 모아 놓은 벤치마크임. 이중 결함 코드의 패턴을 학습할 수 있는 학습 데이터가 충분한 7개의 프로젝트에 대해서 본 발명의 기술이 적용된 전후의  성능을 평가하였음. 7개의 프로젝트 내에는 총 131개의 오류 버전이 있고 각 오류 버전에서 정확하게 결함 위치 추정한 개수로 정확도를 측정하였음. 정확하게 결함 위치 추정을 했다는 것은 의심도 점수가 높은 Top-10라인들 중 실제 결함이 포함된 것으로 하였음. 결함 위치 추정에서 의심도 점수가 동점인 경우 모두 가장 낮은 랭킹을 가지는 것으로 계산하였음. 예를 들어 의심도 점수가 가장 높은 5개의 라인의 의심도 점수가 모두 같을 경우 모두 5등으로 처리하여 정확도를 계산하였음. 베이스라인 결함 위치 추정기는 Ochiai를 사용 하였음.


**정확도 비교:** 아래의 표는 종래의 기술 Ochiai와 개발한 기술의 정확도를 비교함. 개발한 기술은 종래의 기술 Ochiai에 적용되었을 시 아래와 같이 정확도를 75% 향상시켰음. 

|Project|# versions|Ochiai|Ours |
|---|---|---|---|
|cpp_peglib | 10 | 2 | 2 |
|cppcheck| 30 | 0 | 2 | 
|exiv2 | 20 | 5 | 9 | 
|libchewing | 8 | 0 | 0 | 
|libxml2| 7 | 1 | 1 |
|proj| 28 | 0 | 0 |
|openssl | 28 | 0 | 0 |
|Total | 131 | 8 | 14 |

  
8. 보호받고자 하는 핵심 아이디어 (Claims)  

8-1. 독립항 

결함 프로그램 코드 패턴을 이용하여 의심도 점수를 업데이트하는 의심도 점수 업데이트 함수.

8-2. 종속항 1
특정 토큰의 등장 여부로 의심도 점수를 변환하는 기술.

8-3. 종속항 2
타깃 라인의 주변 라인의 패턴을 보고 타깃 라인의 의심도 점수를 변환하는 기술.

8-4. 종속항 3
결함 프로그램 코드 패턴 및 이에 따른 의심도 점수 변화량을 아래와 같이 그래프 형태로 표현하는 기술.

![[Pasted image 20240125130920.png]]

9. 선행자료  

[1] R. Abreu, P. Zoeteweij and A. J. c. Van Gemund, "An Evaluation of Similarity Coefficients for Software Fault Localization," _2006 12th Pacific Rim International Symposium on Dependable Computing (PRDC'06)_, Riverside, CA, USA, 2006, pp. 39-46, doi: 10.1109/PRDC.2006.18.

[2] W. E. Wong, R. Gao, Y. Li, R. Abreu and F. Wotawa, "A Survey on Software Fault Localization," in _IEEE Transactions on Software Engineering_, vol. 42, no. 8, pp. 707-740, 1 Aug. 2016, doi: 10.1109/TSE.2016.2521368.



