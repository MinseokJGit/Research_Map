
# Title: The ART of Sharing Points-to Analysis


In this work, we address the issue of trust, while keeping the issues of performance efficiency in mind. We propose **ART**: Analysis-results Representation Template - a novel scheme to efficiently and concisely encode results of flow-sensitive, context-insensitive points-to analysis computed by a static analyzer for use in any independent system that may benefit from such a highly. precise points-to analysis.

Our scheme has two components: (1) a producer that can statically perform expensive points-to analysis and encode the same concisely. (2) a consumer that, on receiving such encoded results (called Artwork), can regenerate the points-to analysis results encoded by the artwork if it is deemed "safe".

We demonstrate the usage of ART by implementing a producer (in Soot) and two consumers (in Soot and the Eclipse OpenJ9 JIT compiler). We have evaluated our implementation over various benchmarks from the DaCapo and SPEC jvm2008 suites. Our results demonstrate that using ART, a consumer can obtain precise flow-sensitive, context-insensitive points-to analysis results in less than (average) 1% of the time taken by a static analyzer to perform the same analysis, with the storage overhead of ART representing a small faction of the program size (average around 4%).

# Challenges

Owing to the remote and independent nature of the consumer, two important challenges exists:

+ Ensuring safety: given that the virtual machine is an independent system, how does it ensure that the results of an obtained expensive points-to analysis is safe to use?
+ Ensuring transmission efficiency: For a large program, the artifacts of an analysis can potentially be huge. Since any such artifacts have to be transmitted to the JVM along with the bytecode, it effectively increases the size of the executable and is thus considered an overhead that impacts portability.


# Idea

The design of ART is based on the underlying properties of fixed-point computations. Given an _ARTwork_, for an analysis _A_ and program _P_, the consumer makes exactly one pass over the statements of the while-program and regenerate the complete points-to analysis results at each program-point, by using the information present in the _ARTwork_, thereby avoiding any fixed-point computation. Thus the points-to analysis results regenerated from a safe _ARTwork_ is guaranteed to be sound.

The intuition behind the design of ART is that it should only carry information that would be otherwise expensive to compute and the consumer should be able to use this information to regenerate the encoded analysis. To summarize, the OUT information (in R), of the leaders of the key basis-blocks can be used to generate the points-to information for all the statements, without needing any fixed-point computation.



## Background

_Points-to graph_ A points-to graph G(N,E) consists of (1) a set of nodes representing the variables and abstract objects in the program; and (2) a set $E \subseteq (N \times N) \cup (N \times Fields \times N)$ of edges representing the points-to relationships among the nodes in the program. 

_Comparison of points-to information_. Given two instances of points-to information $I_1$ and $I_2$ represented by points-to graphs $G_1$ and $G_2$ respectively, we say: that $I_1$ is "equal to" or "matches" $I_2$ is $G_1 = G_2$. Similarly, we say that $I_1$ "subsumes" $I_2$ (represented as $I_1 \ge I_2$) if $G_2$ is a subgraph of $G_1$.


# ART: Analysis-results Representation Template

ART (1) efficiently encode a summary of the points-to analysis computed by a producer, and (2) quickly regenerate the sound analysis results represented by the encoding in a consumer. 

## Design of Intra-procedural ART

The intuition behind the design of ART is that it should only carry information that would be otherwise expensive to compute and the consumer should be able to use this information to regenerate the encoded analysis.

To summarize, the OUT information (in R), of the leaders of the key basis-blocks can be used to generate the points-to information for all the statements.


# Evaluation

# RQ1. How does the regeneration technique compare to complete analysis in terms of time and precision?

![[Pasted image 20240425155729.png]]
The above figure shows that ART regenerates points-to analysis results by paying an extremely small fraction of the time taken to perform the complete analysis by the producer.

![[Pasted image 20240425155947.png]]
To show that the points-to analysis results regenerated by the consumer is of equal precision as the results encoded by ART, we compared the OUT-summary regenerated by the consumers for each procedure with the OUT-summary of the same procedure as computed by the producer. These OUT-summaries were found to match for all the procedures analyzed for each program, thus showing that the regenerated points-to analysis results are of equal precision to the complete analysis.


# RQ2. Is the proposed scheme able to detect tampering of the generated ARTwork?


# RQ3. What is the cost of regenerating flow-sensitive, context-insensitive analysis during JIT compilation?


# RQ4. What is the storage overhead of artwork?


# RQ5. What is the effect of the optimizations proposed in Section 4 on the size of artwork?


# RQ6. What is the utility of the analysis results regenerated using artwork? 


